package builder

import (
	"strings"
	gotemplate "text/template"

	resource "github.com/GuanceCloud/iacker/pkg/resource/v1"
	naming "github.com/GuanceCloud/iacker/pkg/helpers/naming"
)

#SchemaBuilder: {
	name: string

	pkg: string

	rs: resource.#Resource

	isds: *false | bool

	_resource_template: """
		// Code generated by Guance Cloud Code Generation Pipeline. DO NOT EDIT.

		package {{ .pkg }}

		import (
			"github.com/hashicorp/terraform-plugin-framework/resource/schema"
			"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
			"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
			"github.com/hashicorp/terraform-plugin-framework/types"
		)

		var resourceSchema = schema.Schema{
			Description: "{{ .rs.title.en }}",
			MarkdownDescription: resourceDocument,
			Attributes: map[string]schema.Attribute{
				"id": schema.StringAttribute{
					Description: "The Generic Resource Name (GRN) of cloud resource.",
					Computed:    true,
					PlanModifiers: []planmodifier.String{
						stringplanmodifier.UseStateForUnknown(),
					},
				},

				"created_at": schema.StringAttribute{
					Description: "The RFC3339/ISO8601 time string of resource created at.",
					Computed:    true,
				},

				{{ range $v := .properties }}
					{{ $v }}
				{{ end }}
			},
		}
		"""

	_data_source_template: """
		// Code generated by Guance Cloud Code Generation Pipeline. DO NOT EDIT.

		package {{ .pkg }}

		import (
			"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
		)

		var dataSourceSchema = schema.Schema{
			Description: "{{ .rs.title.en }}",
			MarkdownDescription: resourceDocument,
			Attributes: map[string]schema.Attribute{
				"id": schema.StringAttribute{
					Description: "The hash id of the resource.",
					Computed:    true,
				},

				"max_results": schema.Int64Attribute{
					Description: "The max results count of the resource will be returned.",
					Optional: true,
				},

				"filters": schema.ListNestedAttribute{
					Description: "The list of the resource",
					Optional:    true,
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
							"name": schema.StringAttribute{
								Description: "The filter path, represent as json path.",
								Required: true,
							},

							"values": schema.ListAttribute{
								ElementType:         types.StringType,
								Required: true,
								Description:         "The filter values",
							},
						},
					},
				},

				"items": schema.ListNestedAttribute{
					Description: "The list of the resource",
					Computed: true,
					NestedObject: schema.NestedAttributeObject{
						Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Description: "The Guance Resource Name (GRN) of cloud resource.",
									Computed:    true,
								},

								"created_at": schema.StringAttribute{
									Description: "The RFC3339/ISO8601 time string of resource created at.",
									Computed:    true,
								},

							{{ range $v := .properties }}
								{{ $v }}
							{{ end }}
						},
					},
				},
			},
		}
		"""

	_model_template: """
		// schema{{ .name.uppercamel }} maps the resource schema data.
		var schema{{ .name.uppercamel }} = map[string]schema.Attribute{
			{{- range $v := .properties }}
			{{ $v }}
			{{ end }}
		}
		"""

	_prop_template: """
		"{{ .name.snake }}":
		{{- if eq .prop.schema.type "array" -}}
			{{- if eq .prop.schema.elem.type "object" }}
			schema.ListNestedAttribute{
				{{- template "option" .prop }}
				NestedObject: schema.NestedAttributeObject{
					Attributes: schema{{ .prop.schema.elem.model }},
				},
			}
			{{- else if eq .prop.schema.elem.type "ref" }}
			schema.ListAttribute{
				{{- template "option" .prop }}
				ElementType: types.StringType,
				{{ if not .isds }}PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},{{ end }}
			}
			{{- else }}
			schema.ListAttribute{
				{{- template "option" .prop }}
				ElementType: {{ template "type" .prop.schema.elem }},
				{{ if not .isds }}PlanModifiers: []planmodifier.List{
					listplanmodifier.RequiresReplace(),
				},{{ end }}
			}
			{{- end }}
		{{- else if eq .prop.schema.type "object" -}}
			schema.SingleNestedAttribute{
				{{- template "option" .prop }}
				Attributes: schema{{ .prop.schema.model }},
			}
		{{- else if eq .prop.schema.type "ref" -}}
			schema.StringAttribute{
				{{- template "option" .prop }}
				{{ if not .isds }}PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
				{{ end }}
			}
		{{- else -}}
			{{ template "primitive" .prop }}
		{{- end -}}
		,

		{{- define "primitive" }}
			{{- if eq .schema.type "integer" -}}
				schema.Int64Attribute{
					{{- template "option" . }}
					{{ if not .isds }}PlanModifiers: []planmodifier.Int64{
						int64planmodifier.RequiresReplace(),
					},
					{{ end }}
				}
			{{- else if eq .schema.type "boolean" -}}
				schema.BoolAttribute{
					{{- template "option" . }}
					{{ if not .isds }}PlanModifiers: []planmodifier.Bool{
						boolplanmodifier.RequiresReplace(),
					},
					{{ end }}
				}
			{{- else if eq .schema.type "float" -}}
				schema.Float64Attribute{
					{{- template "option" . }}
					{{ if not .isds }}PlanModifiers: []planmodifier.Float64{
						float64planmodifier.RequiresReplace(),
					},
					{{ end }}
				}
			{{- else if eq .schema.type "string" -}}
				schema.StringAttribute{
					{{- template "option" . }}
					{{ if not .isds }}PlanModifiers: []planmodifier.String{
						stringplanmodifier.RequiresReplace(),
					},{{ end }}
					{{ if .schema.enum }}Validators: []validator.String{
						stringvalidator.OneOf({{ range $v := .schema.enum }}"{{ $v.value }}",{{ end }}),
					},{{ end }}
				}
			{{- else -}}
				unsupported type: {{ .schema.type }}
			{{- end -}}
		{{- end }}


		{{- define "option" }}
			{{ if not (eq .title.en "") -}}
				Description: "{{ .title.en }}",
			{{ end }}
			{{ if .schema.enum }}
				MarkdownDescription: `
				{{ .title.en }}, value must be one of: {{ range $v := .schema.enum }}*{{ $v.value }}*, {{ end }}other value will be ignored.
				`,
			{{ end }}
			
			{{- if .schema.required -}}
				Required: true,
			{{- else }}
				Optional: true,
			{{- end -}}
			{{- if .meta.dynamic -}}
				Computed: true,
			{{- end -}}
		{{- end }}


		{{- define "type" }}
			{{- if eq .type "integer" -}}
				types.Int64Type
			{{- else if eq .type "boolean" -}}
				types.BoolType
			{{- else if eq .type "float" -}}
				types.Float64Type
			{{- else if eq .type "string" -}}
				types.StringType
			{{- else -}}
				unsupported type: {{ .type }}
			{{- end -}}
		{{- end }}
		"""

	_resource: gotemplate.Execute(_resource_template, {
		"name": naming.#UpperCamel & {"name": name}
		"pkg":  pkg
		"rs":   rs
		properties: [
			for i, pinfo in rs.models[name].properties {
				gotemplate.Execute(_prop_template, {
					name:  naming.#Snake & {"name": pinfo.name}
					prop:  pinfo
					index: i + 1
				})
			},
		]
	})

	_data_source: gotemplate.Execute(_data_source_template, {
		"name": naming.#UpperCamel & {"name": name}
		"pkg":  pkg
		"rs":   rs
		properties: [
			for i, pinfo in rs.models[name].properties {
				gotemplate.Execute(_prop_template, {
					name: naming.#Snake & {"name": pinfo.name}
					prop: {
						"isds": isds
						for k, v in pinfo {
							"\(k)": v
						}
					}
					index: i + 1
				})
			},
		]
	})

	_models: [
		for mname, minfo in rs.models if mname != name {
			gotemplate.Execute(_model_template, {
				name: naming.#UpperCamel & {"name": mname}
				v:    minfo
				properties: [
					for i, pinfo in minfo.properties {
						gotemplate.Execute(_prop_template, {
							name: naming.#Snake & {"name": pinfo.name}
							prop: {
								"isds": isds
								for k, v in pinfo {
									"\(k)": v
								}
							}
							index: i + 1
						})
					},
				]
			})
		},
	]

	_block_sep: "\n" * 2
	if !isds {
		output: _resource + _block_sep + strings.Join(_models, _block_sep)
	}
	if isds {
		output: _data_source + _block_sep + strings.Join(_models, _block_sep)
	}
}
